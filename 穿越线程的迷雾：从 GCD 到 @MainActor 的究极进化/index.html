<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sseen.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":false,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":150,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="同样的提示词，用的 gemini 3 pro（high），和 Claude opus 4.5 生成，感觉还是谷歌更厉害一点。 prompt： 关于@MainActor 只对 async 函数自动切换线程，didSet 不是 async 的这个问题，用大师级的逻辑和语言组织一篇博客，顺便对比下 OperationQueue.main.addOperation DispatchQueue.main">
<meta property="og:type" content="article">
<meta property="og:title" content="穿越线程的迷雾：从 GCD 到 @MainActor 的究极进化">
<meta property="og:url" content="https://sseen.github.io/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E9%9B%BE%EF%BC%9A%E4%BB%8E%20GCD%20%E5%88%B0%20@MainActor%20%E7%9A%84%E7%A9%B6%E6%9E%81%E8%BF%9B%E5%8C%96/index.html">
<meta property="og:site_name" content="许笋的 blog">
<meta property="og:description" content="同样的提示词，用的 gemini 3 pro（high），和 Claude opus 4.5 生成，感觉还是谷歌更厉害一点。 prompt： 关于@MainActor 只对 async 函数自动切换线程，didSet 不是 async 的这个问题，用大师级的逻辑和语言组织一篇博客，顺便对比下 OperationQueue.main.addOperation DispatchQueue.main">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-09T13:00:00.000Z">
<meta property="article:modified_time" content="2025-12-19T07:19:01.839Z">
<meta property="article:author" content="sseen">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Concurrency">
<meta property="article:tag" content="MainActor">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://sseen.github.io/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E9%9B%BE%EF%BC%9A%E4%BB%8E%20GCD%20%E5%88%B0%20@MainActor%20%E7%9A%84%E7%A9%B6%E6%9E%81%E8%BF%9B%E5%8C%96/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sseen.github.io/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E9%9B%BE%EF%BC%9A%E4%BB%8E%20GCD%20%E5%88%B0%20@MainActor%20%E7%9A%84%E7%A9%B6%E6%9E%81%E8%BF%9B%E5%8C%96/","path":"穿越线程的迷雾：从 GCD 到 @MainActor 的究极进化/","title":"穿越线程的迷雾：从 GCD 到 @MainActor 的究极进化"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>穿越线程的迷雾：从 GCD 到 @MainActor 的究极进化 | 许笋的 blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
  <div class="innerClipped">
    <div class="background"></div>
    <div class="fill"></div>
    <div class="mask"></div>
    <div class="shadow"></div>
    <div class="light"></div>
    <div class="gloss"></div>
    <div class="text">许笋的 blog </div>
  </div>
</a>
      <p class="site-subtitle" itemprop="description">大平层</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%B9%95%EF%BC%9A%E6%B4%AA%E8%8D%92%E6%97%B6%E4%BB%A3-%E2%80%94%E2%80%94-OperationQueue-main"><span class="nav-number">1.</span> <span class="nav-text">第一幕：洪荒时代 —— OperationQueue.main</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%B9%95%EF%BC%9A%E5%B7%A5%E4%B8%9A%E9%9D%A9%E5%91%BD-%E2%80%94%E2%80%94-DispatchQueue-main"><span class="nav-number">2.</span> <span class="nav-text">第二幕：工业革命 —— DispatchQueue.main</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%B9%95%EF%BC%9A%E9%87%8F%E5%AD%90%E8%B7%83%E8%BF%81-%E2%80%94%E2%80%94-MainActor"><span class="nav-number">3.</span> <span class="nav-text">第三幕：量子跃迁 —— @MainActor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">1. 为什么它是革命性的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E7%97%9B%E7%82%B9%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF-async%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">2. 核心痛点：为什么必须是 async？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%A7%A3%E5%AF%86-didSet-%E7%9A%84%E5%B0%B4%E5%B0%AC%E5%A4%84%E5%A2%83"><span class="nav-number">3.3.</span> <span class="nav-text">3. 解密 didSet 的尴尬处境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%89%E8%80%85%E7%9A%84%E5%93%B2%E5%AD%A6%E5%B7%AE%E5%BC%82"><span class="nav-number">3.4.</span> <span class="nav-text">总结：三者的哲学差异</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%B8%BA%E4%BD%95-UI-%E5%BF%85%E9%A1%BB%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">第一章：为何 UI 必须在主线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%89%E7%A7%8D%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">第二章：三种主线程调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-OperationQueue-main-%E2%80%94%E2%80%94-%E5%85%83%E8%80%81%E7%BA%A7%E9%80%89%E6%89%8B"><span class="nav-number">5.1.</span> <span class="nav-text">2.1 OperationQueue.main —— 元老级选手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-DispatchQueue-main-%E2%80%94%E2%80%94-GCD-%E7%9A%84%E4%B8%BB%E5%8A%9B%E5%86%9B"><span class="nav-number">5.2.</span> <span class="nav-text">2.2 DispatchQueue.main —— GCD 的主力军</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-MainActor-%E2%80%94%E2%80%94-Swift-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%96%B0%E6%98%9F"><span class="nav-number">5.3.</span> <span class="nav-text">2.3 @MainActor —— Swift 并发的新星</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AdidSet-%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">6.</span> <span class="nav-text">第三章：didSet 的陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94"><span class="nav-number">7.</span> <span class="nav-text">第四章：三者对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">8.</span> <span class="nav-text">第五章：最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="nav-number">8.1.</span> <span class="nav-text">5.1 选择指南</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-MainActor-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF"><span class="nav-number">8.2.</span> <span class="nav-text">5.2 @MainActor 的正确姿势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%B1%9E%E6%80%A7%E8%A7%82%E5%AF%9F%E5%99%A8%E4%B8%AD%E7%9A%84-UI-%E6%9B%B4%E6%96%B0"><span class="nav-number">8.3.</span> <span class="nav-text">5.3 属性观察器中的 UI 更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%AB%A0%EF%BC%9A%E6%80%9D%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">终章：思考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sseen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">277</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">329</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sseen.github.io/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E9%9B%BE%EF%BC%9A%E4%BB%8E%20GCD%20%E5%88%B0%20@MainActor%20%E7%9A%84%E7%A9%B6%E6%9E%81%E8%BF%9B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sseen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="许笋的 blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="穿越线程的迷雾：从 GCD 到 @MainActor 的究极进化 | 许笋的 blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          穿越线程的迷雾：从 GCD 到 @MainActor 的究极进化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-12-09 13:00:00" itemprop="dateCreated datePublished" datetime="2025-12-09T13:00:00+00:00">2025-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-19 07:19:01" itemprop="dateModified" datetime="2025-12-19T07:19:01+00:00">2025-12-19</time>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>同样的提示词，用的 gemini 3 pro（high），和 Claude opus 4.5 生成，感觉还是谷歌更厉害一点。<br>
prompt：<br>
关于@MainActor 只对 async 函数自动切换线程，didSet 不是 async 的这个问题，用大师级的逻辑和语言组织一篇博客，顺便对比下<br>
OperationQueue.main.addOperation<br>
DispatchQueue.main<br>
MainActor<br>
三者，由浅入深的，徐徐道来</p>
</blockquote>
<p>在 Swift 并发编程的江湖里，“回到主线程更新 UI” 是一条铁律。但即使是老手，面对 <code>@MainActor</code> 时偶尔也会在深夜的调试中怀疑人生：<em>“为什么我加了 @MainActor，这个属性的 didSet 还是不能像我想象的那样工作？”</em></p>
<p>今天，我们就用大师级的视角，剥开 <code>async</code> 的外衣，聊聊这段横跨十年的技术变迁，以及为什么 <code>didSet</code> 成了那个 “无法暂停的瞬间”。</p>
<h2 id="第一幕：洪荒时代-——-OperationQueue-main">第一幕：洪荒时代 —— OperationQueue.main</h2>
<p>在 GCD 统治世界之前，<code>OperationQueue</code> 是 Obj-C 时代的王者。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token class-name">OperationQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>addOperation <span class="token punctuation">&#123;</span>
    <span class="token comment">// 更新 UI</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Done"</span></span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>它的本质是什么？</strong><br>
它是<strong>面向对象</strong>的任务队列。它不仅仅是抛一个闭包过去，它把任务封装成了 <code>Operation</code> 对象。这使得它拥有了 GCD 难以企及的高级能力：</p>
<ul>
<li><strong>依赖管理</strong>（A 必须在 B 之后执行）</li>
<li><strong>取消机制</strong>（虽然要手动检查 <code>isCancelled</code>）</li>
<li><strong>并发数控制</strong></li>
</ul>
<p>但它的缺点也很明显：<strong>重</strong>。每次切回主线程都要创建一个 Operation 对象，对于高频的 UI 刷新来说，就像是为了买瓶酱油开了一辆重型卡车去便利店。</p>
<h2 id="第二幕：工业革命-——-DispatchQueue-main">第二幕：工业革命 —— DispatchQueue.main</h2>
<p>Grand Central Dispatch (GCD) 的出现，把我们带入了 <strong>C 语言配合 Block</strong> 的高效时代。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 更新 UI</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Done"</span></span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>它的本质是什么？</strong><br>
它是<strong>FIFO（先进先出）的底层队列</strong>。</p>
<ul>
<li><strong>快而狠</strong>：极低的轻量级开销，闭包扔进去就完事。</li>
<li><strong>由浅入深</strong>：看似简单，实则暗藏杀机。你一定写过这样的代码：<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 经典死锁</span>
<span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>sync <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span> </code></pre>
或者在复杂的嵌套闭包中迷失了 <code>self</code> 的持有关系。</li>
</ul>
<p><code>DispatchQueue</code> 最大的问题在于：<strong>它是“盲”的</strong>。编译器完全不知道这个闭包会在哪里运行。你全凭<strong>人工肉眼</strong>去保证 “这段代码一定要在主线程跑”。只要你手一抖，Crush 就在角落里等着你。它是一种<strong>运行时的约定</strong>，而非编译时的保证。</p>
<h2 id="第三幕：量子跃迁-——-MainActor">第三幕：量子跃迁 —— @MainActor</h2>
<p>Swift Concurrency (Swift 5.5+) 的到来，是一场编译器层面的革命。<code>@MainActor</code> 不再是一个简单的 API，它是一个<strong>编译器约束的契约</strong>。</p>
<h3 id="1-为什么它是革命性的？">1. 为什么它是革命性的？</h3>
<p>这不再是你手动 <code>dispatch</code>，而是你告诉编译器：“这个可以随便跑，但那个必须在主线程跑。”</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">ViewModel</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">""</span></span>
    
    <span class="token attribute atrule">@MainActor</span>
    <span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 编译器保证：这里一定是主线程</span>
        label<span class="token punctuation">.</span>text <span class="token operator">=</span> name 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>如果你在后台线程试图调用 <code>vm.updateUI()</code>，编译器会直接报错，或者强制你使用 <code>await</code>。<strong>这就是安全感的来源。</strong></p>
<h3 id="2-核心痛点：为什么必须是-async？">2. 核心痛点：为什么必须是 async？</h3>
<p>回到最初的问题：<em>“@MainActor 只对 async 函数自动切换线程”。</em></p>
<p>想象一下，你正在后台线程（Thread B）飞快地跑着，突然要调用一个 <code>@MainActor</code> 的方法。这意味着执行流必须<strong>跳</strong>到主线程（Thread A）。</p>
<p>在计算机科学里，<strong>“跳” 意味着 “等”</strong>。<br>
Thread B (后台) 不能直接把手伸进 Thread A (主线程) 里操作，它必须把任务打包，扔给 A，然后挂起自己（suspend），等待 A 处理完，再恢复执行（resume）。</p>
<p><strong>这个“挂起等待”的过程，就是 <code>await</code> 的本质。</strong></p>
<p>如果不标记为 <code>async</code>（异步），函数就是同步的（synchronous）。同步意味着**“此时此刻，立即执行，不能中断”**。<br>
如果在后台线程调用一个同步的 MainActor 方法，又不能 await，那就违反了物理定律——你不能在不切换上下文的情况下，既在 B 跑又在 A 跑。</p>
<h3 id="3-解密-didSet-的尴尬处境">3. 解密 didSet 的尴尬处境</h3>
<p>现在我们来看那个让你抓狂的场景：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">ViewModel</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 这是一个普通的、非隔离的属性</span>
    <span class="token keyword">var</span> status<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Idle"</span></span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Status changed to </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">status</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
            
            <span class="token comment">// ❌ 编译错误：Call to main actor-isolated instance method 'updateUI()' in a synchronous nonisolated context</span>
            <span class="token function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token attribute atrule">@MainActor</span> 
    <span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"UI Updated"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>这里是大多数人最困惑的地方：</strong><br>
<em>“我不理解！我已经把 <code>updateUI</code> 标记为 <code>@MainActor</code> 了，这不就代表它是主线程了吗？为什么编译器还是不让我调？”</em></p>
<p><strong>核心误解：你把“目的地”当成了“传送门”。</strong></p>
<p><code>@MainActor</code> 标记在函数上，类似于在门口挂了一个牌子：<strong>“闲人免进，只有主线程能进”</strong>。<br>
它虽然定义了<strong>代码在哪里跑</strong>，但它没有改变<strong>你在哪里调</strong>。</p>
<p>当你身处后台线程（<code>didSet</code> 的执行环境）时，你站在门外。<br>
你想进去（调用 <code>updateUI</code>），但门上写着“主线程专用”。<br>
这时候你需要做一个动作：<strong>切换线程</strong>（穿过传送门）。</p>
<p>在计算机的世界里，切换线程不是瞬间完成的（主线程可能正在忙着画 UI，你得排队）。<br>
<strong>排队 = 等待 = <code>await</code>。</strong></p>
<p>所以，虽然 <code>updateUI</code> <em>是</em> 主线程的，但你 <em>去</em> 那里的过程必须是异步的。<br>
而 <code>didSet</code> 说：“我不接受等待，我有急事，马上要执行完。”</p>
<p>这就死锁了逻辑：<strong>你要去一个必须排队的地方，但你却在一个不允许排队的函数里。</strong></p>
<p><strong>这就是为什么你怀念 <code>DispatchQueue.main</code> 的原因。</strong></p>
<p>在老时代，你可以做一个“发射后不管”的操作：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 依然是在后台线程，但我把任务扔出去就不管了</span>
    <span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span></code></pre>
<p>但在 Swift Concurrency 的世界里，编译器希望你<strong>显式处理并发</strong>。它不允许你在一个同步的、非隔离的上下文中，隐式地发起一个跨 Actor 的调用。</p>
<p><strong>怎么解？</strong><br>
最“正统”的解法是把 <code>Task</code> 显式写出来（虽然看起来变啰嗦了，但这正是 Swift 想告诉你的：<em>“嘿，兄弟，这里发起了一个异步任务！”</em>）：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 显式开启一个新的异步任务上下文</span>
    <span class="token class-name">Task</span> <span class="token punctuation">&#123;</span> <span class="token attribute atrule">@MainActor</span> <span class="token keyword">in</span>
        <span class="token function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>或者，让 <code>ViewModel</code> 整个服从于 <code>@MainActor</code>，这样 setter 本身就在主线程，调用 <code>updateUI</code> 就变成了自家后院散步，畅通无阻。</p>
<h3 id="总结：三者的哲学差异">总结：三者的哲学差异</h3>
<ul>
<li><strong>OperationQueue.main</strong>：像一位<strong>老管家</strong>。做事井井有条，懂依赖，懂撤销，但请他办事流程繁琐，开销大。</li>
<li><strong>DispatchQueue.main</strong>：像一位<strong>快递员</strong>。在这里签字，包裹扔上车就走。快，但不管包裹里是啥，也不管你是不是把易碎品（UI更新）扔到了堆场（后台）里。一切责任自负。</li>
<li><strong>@MainActor</strong>：像一套<strong>交通法规</strong>。它不再依赖人的自觉，而是由红绿灯（编译器）强制执行。
<ul>
<li><strong>Async</strong> 是那盏红灯：<em>“前方进入主线程管制区，非本地车辆请熄火等待（await）切换。”</em></li>
<li><strong>didSet</strong> 是管制区内的<strong>快速通道</strong>：<em>“既然进来了，就请快速通过，不要停车（suspend）。”</em></li>
</ul>
</li>
</ul>
<p>理解了这一点，你就明白了：不是 <code>@MainActor</code> 不够智能，而是它太懂<strong>线程安全</strong>的代价了。它强迫你在跨越线程边界的那一刻，显式地承认：<strong>“我愿意等待。”</strong></p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">(以下是 Claude opus 4.5 生成)

<span class="token title important"><span class="token punctuation">#</span> 从一个诡异的 Crash 说起：Swift 主线程调度的三生三世</span>

<span class="token title important"><span class="token punctuation">##</span> 引子：一个看似正确的代码</span>

```swift
var fallAlertList: [CameraInfo] = [] &#123;
    didSet &#123;
        updateNextButton()  // ❌ Crash!
    &#125;
&#125;

@MainActor
private func updateNextButton() &#123;
    nextButton.isHidden = fallAlertList.count &lt;= 1
&#125;</code></pre>
<p>代码看起来无懈可击——<code>@MainActor</code> 标记了 <code>updateNextButton()</code>，理应在主线程执行。然而，控制台却无情地抛出：</p>
<pre class="language-none"><code class="language-none">Main Thread Checker: UI API called on a background thread</code></pre>
<p>这究竟是怎么回事？</p>
<h2 id="第一章：为何-UI-必须在主线程？">第一章：为何 UI 必须在主线程？</h2>
<p>在探讨解决方案之前，我们需要理解一个根本性问题：<strong>为什么 UIKit 不是线程安全的？</strong></p>
<p>UIKit 诞生于 2008 年，那是一个单核 CPU 的时代。苹果工程师做了一个务实的决定：<strong>不为 UIKit 添加线程锁</strong>。原因很简单：</p>
<ol>
<li><strong>性能</strong>：锁是昂贵的，每次 UI 操作都加锁会严重影响流畅度</li>
<li><strong>复杂度</strong>：多线程 UI 框架极易产生死锁和竞态条件</li>
<li><strong>必要性</strong>：当时的设备根本不需要</li>
</ol>
<p>这个决定延续至今。所以，所有 UI 操作必须在主线程（也叫 UI 线程）执行，否则会出现：</p>
<ul>
<li>界面撕裂</li>
<li>莫名其妙的崩溃</li>
<li>数据不一致</li>
</ul>
<h2 id="第二章：三种主线程调度方式">第二章：三种主线程调度方式</h2>
<h3 id="2-1-OperationQueue-main-——-元老级选手">2.1 OperationQueue.main —— 元老级选手</h3>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token class-name">OperationQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>addOperation <span class="token punctuation">&#123;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
<span class="token punctuation">&#125;</span></code></pre>
<p><code>OperationQueue</code> 是 Foundation 框架的一部分，封装了 GCD，提供了更高层的抽象。<code>OperationQueue.main</code> 是一个特殊的队列，它的所有操作都在主线程执行。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可以设置依赖关系（Operation A 完成后才执行 B）</li>
<li>可以取消操作</li>
<li>可以设置最大并发数（但 main queue 永远是串行的）</li>
<li>语法略显冗长</li>
</ul>
<p><strong>适用场景：</strong> 需要复杂任务调度、依赖管理的场景。</p>
<h3 id="2-2-DispatchQueue-main-——-GCD-的主力军">2.2 DispatchQueue.main —— GCD 的主力军</h3>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
<span class="token punctuation">&#125;</span></code></pre>
<p>Grand Central Dispatch (GCD) 是苹果在 iOS 4 引入的底层并发框架。<code>DispatchQueue.main</code> 直接对应主线程。</p>
<p><strong>两种调用方式：</strong></p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 异步：将任务放入队列，立即返回，不阻塞当前线程</span>
<span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span>

<span class="token comment">// 同步：将任务放入队列，等待执行完成才返回</span>
<span class="token comment">// ⚠️ 如果当前已在主线程调用 sync，会死锁！</span>
<span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>sync <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span></code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>轻量、高效</li>
<li>语法简洁</li>
<li>是最常用的主线程调度方式</li>
</ul>
<p><strong>适用场景：</strong> 绝大多数需要切换到主线程的场景。</p>
<h3 id="2-3-MainActor-——-Swift-并发的新星">2.3 @MainActor —— Swift 并发的新星</h3>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token attribute atrule">@MainActor</span>
<span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
<span class="token punctuation">&#125;</span></code></pre>
<p><code>@MainActor</code> 是 Swift 5.5 引入的 Actor 隔离机制的一部分。它是一个<strong>全局 Actor</strong>，代表主线程。</p>
<p><strong>关键认知：<code>@MainActor</code> 是编译时约束，不是运行时魔法</strong></p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// ✅ async 函数：运行时会自动切换到主线程</span>
<span class="token attribute atrule">@MainActor</span>
<span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ⚠️ 非 async 函数：只有编译时检查，没有运行时切换！</span>
<span class="token attribute atrule">@MainActor</span>
<span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
<span class="token punctuation">&#125;</span></code></pre>
<p>当你从非隔离上下文调用非 async 的 <code>@MainActor</code> 函数时，Swift 编译器会警告你，但<strong>不会自动切换线程</strong>。这正是开篇那个 bug 的根源。</p>
<h2 id="第三章：didSet-的陷阱">第三章：didSet 的陷阱</h2>
<p>让我们回到开篇的问题：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> fallAlertList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">CameraInfo</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
        <span class="token function">updateNextButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 在哪个线程执行？</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>didSet 在什么线程执行？答案是：修改属性的那个线程。</strong></p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 在后台线程修改</span>
<span class="token class-name">URLSession</span><span class="token punctuation">.</span>shared<span class="token punctuation">.</span><span class="token function">dataTask</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> data<span class="token punctuation">,</span> <span class="token omit keyword">_</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span>
    <span class="token comment">// 这里是后台线程！</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>fallAlertList <span class="token operator">=</span> newData  <span class="token comment">// didSet 在后台线程触发</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>而 <code>@MainActor</code> 标记的非 async 函数，不会自动切换线程。所以：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token attribute atrule">@MainActor</span>
<span class="token keyword">private</span> <span class="token keyword">func</span> <span class="token function-definition function">updateNextButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 没有 async！</span>
    nextButton<span class="token punctuation">.</span>isHidden <span class="token operator">=</span> <span class="token operator">...</span>      <span class="token comment">// 💥 在后台线程执行</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>解决方案：</strong></p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> fallAlertList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">CameraInfo</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span>
            <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">updateNextButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>或者使用 async 版本：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> fallAlertList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">CameraInfo</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Task</span> <span class="token punctuation">&#123;</span> <span class="token attribute atrule">@MainActor</span> <span class="token keyword">in</span>
            <span class="token function">updateNextButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<hr>
<h2 id="第四章：三者对比">第四章：三者对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>OperationQueue.main</th>
<th>DispatchQueue.main</th>
<th>@MainActor</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>引入版本</strong></td>
<td>iOS 2</td>
<td>iOS 4</td>
<td>iOS 15 / Swift 5.5</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>封装 GCD</td>
<td>libdispatch</td>
<td>Swift Runtime</td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td>冗长</td>
<td>简洁</td>
<td>最简洁</td>
</tr>
<tr>
<td><strong>取消支持</strong></td>
<td>✅</td>
<td>❌</td>
<td>✅ (Task)</td>
</tr>
<tr>
<td><strong>依赖管理</strong></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>编译时检查</strong></td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>自动线程切换</strong></td>
<td>✅</td>
<td>✅</td>
<td>⚠️ 仅 async</td>
</tr>
<tr>
<td><strong>与 async/await 集成</strong></td>
<td>需包装</td>
<td>需包装</td>
<td>原生支持</td>
</tr>
</tbody>
</table>
<h2 id="第五章：最佳实践">第五章：最佳实践</h2>
<h3 id="5-1-选择指南">5.1 选择指南</h3>
<pre class="language-none"><code class="language-none">需要复杂调度&#x2F;取消？ → OperationQueue
简单的线程切换？   → DispatchQueue.main.async
Swift 并发代码？   → @MainActor + async&#x2F;await</code></pre>
<h3 id="5-2-MainActor-的正确姿势">5.2 @MainActor 的正确姿势</h3>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// ✅ 推荐：整个类标记为 @MainActor</span>
<span class="token attribute atrule">@MainActor</span>
<span class="token keyword">class</span> <span class="token class-name">MyViewController</span><span class="token punctuation">:</span> <span class="token class-name">UIViewController</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 自动在主线程</span>
        label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ✅ 推荐：async 函数</span>
<span class="token attribute atrule">@MainActor</span>
<span class="token keyword">func</span> <span class="token function-definition function">fetchAndUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    label<span class="token punctuation">.</span>text <span class="token operator">=</span> data  <span class="token comment">// 安全</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ⚠️ 注意：非 async 函数需要确保调用上下文</span>
<span class="token attribute atrule">@MainActor</span>
<span class="token keyword">func</span> <span class="token function-definition function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    label<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ❌ 危险：在后台线程调用非 async 的 @MainActor 函数</span>
<span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">updateUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 可能崩溃！</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="5-3-属性观察器中的-UI-更新">5.3 属性观察器中的 UI 更新</h3>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// ✅ 安全写法</span>
<span class="token keyword">var</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span>
            <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span>tableView<span class="token punctuation">.</span><span class="token function">reloadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ✅ Swift 并发写法</span>
<span class="token keyword">var</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">didSet</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Task</span> <span class="token punctuation">&#123;</span> <span class="token attribute atrule">@MainActor</span> <span class="token keyword">in</span>
            tableView<span class="token punctuation">.</span><span class="token function">reloadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="终章：思考">终章：思考</h2>
<p>Swift 并发模型的引入，标志着苹果从「程序员负责线程安全」向「编译器保证线程安全」的转变。<code>@MainActor</code> 是这个愿景的一部分，但它不是银弹。</p>
<p>理解它的边界——<strong>只有 async 函数才有运行时线程切换</strong>——才能避免那些诡异的崩溃。</p>
<p>在新旧世界交汇的今天，<code>DispatchQueue.main.async</code> 依然是最可靠的主线程调度方式。而当你的项目完全拥抱 Swift 并发时，<code>@MainActor</code> + <code>async/await</code> 将带来更优雅、更安全的代码。</p>
<p><strong>记住：代码的安全性，永远建立在对其行为的深刻理解之上。</strong></p>
<p><em>— 2025.12.08</em></p>
<pre><code></code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Swift/" rel="tag"># Swift</a>
              <a href="/tags/Concurrency/" rel="tag"># Concurrency</a>
              <a href="/tags/MainActor/" rel="tag"># MainActor</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Biome%20%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95%EF%BC%9A%E5%BD%93%E7%94%A8%E6%88%B7%E5%90%8D%E9%81%87%E4%B8%8A%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/" rel="prev" title="Biome 配置踩坑实录：当用户名遇上特殊字符">
                  <i class="fa fa-angle-left"></i> Biome 配置踩坑实录：当用户名遇上特殊字符
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Java%20Spring%20Boot%20%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/" rel="next" title="Java Spring Boot 后端项目本地开发环境搭建完全指南">
                  Java Spring Boot 后端项目本地开发环境搭建完全指南 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">sseen</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"sseen/my_blog_utterances","issue_term":"pathname","theme":"preferred-color-scheme"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
